# 1. 해시 함수와 비대칭 암호화 기법

## 해시 함수

- 입력의 길이에 상관없이 항상 고정된 길이의 출력을 생성하는 함수
- 블록체인에서는 문서의 변경을 손쉽게 탐지할 수 있는 방법으로 활용됨

### 암호화 해시 H의 네가지 조건

1. 계산의 용의성 (easy)
   - 메시지m에 대한 해시 계산은 매우 간편해야 함

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24585757-a1c9-42dd-83c1-f7b7e86b60f0/Untitled.png)

1. 원상회피 (Pre-image resistance)
   - 어떤 경우라도 해시 값으로부터 원래의 메시지를 복원하는 것은 불가능해야 한다
   - 다항 시간에 해결할 수 있는 해법이 존재하지 않는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6579377a-97f3-4350-94ad-e15c205626ab/Untitled.png)

1. 두 번째 원상 회피 (Second Pre-image resistance)
   - 메시지 m에 대해 이와 동일한 출력을 생성하는 또 다른 메시지 m’를 찾는 것은 불가능해야한다
   - 충돌은 불가능하다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0e15557-f0b5-421c-bdcb-bfa6013fc514/Untitled.png)

1. 충돌 회피 (Collision resistance)
   - 동일한 출력 결과를 생성하는 서로 다른 두 메시지를 찾는 것은 불가능 하다
   - 충돌은 불가능하다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9bcc5ad-7e7b-446a-a1d3-72cea1d7b04f/Untitled.png)

<aside>
💡 안전한 해시함수란, 항상 고정된 길이를 출력하되 어떤 경우든 그 원메시지가 무엇인지 찾을 수 없어야 하며, 입력이 다르면 항상 다른 출력이 달라지는 ‘충돌 회피’의 성질을 만족해야 함

</aside>

## SHA-256과 해시 퍼즐

- 비트코인 블록체인에 사용하는 해시함수
- 그 입력에 상관없이 항상 256바이트(32비트)의 출력을 생성
- 비트코인은 SHA-256을 두 번 적용한 해시 값을 사용
  - 블록의 고유한 해시 값을 계산할 때도 블록 데이터를 연속해 두 번 해시한 후 사용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3503ee2f-6149-4e37-a3ed-91f04ac817a9/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7eb46855-3099-41fe-a657-664eb42ec80a/Untitled.png)

- 10만 권에 들어 있는 내용 전체에 SHA-256 해시 함수를 적용하면, 그 결과는 해시함수의 기본 성질에 따라 32바이트 정수가 된다
- 데이터가 변경 된다면 해시 함수의 충돌 회피의 성질에 따라 해시값이 변경되어 쉽게 변경됐다고 탐지 가능
- 어디가, 어떻게, 얼마나 변경됬는지는 알 수 없음

## 머클트리

- 해시 값으로 구성된 트리로서 이진 트리형태를 취하는 데이터 구조
- 비트코인은 모든 트랜잭션에 대한 단일 해시 값을 저장하기 위해 머클트리를 이용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fbd086c-b2a9-4f9a-81f1-ae6e1f9d8d7d/Untitled.png)

- 트랜잭션을 2개씩 짝지어 해시 값을 만들고 이렇게 만들어진 해시 값을 또 다시 2개씩 짝지어 반복적으로 해시값을 생성
- 머클트리는 이진 트리 성질로 인해 항상 짝수 개의 데이터가 필요
- 각 노드에서 사용하는 해시 함수는 Hash(x) = SHA256 ( SHA256 ( x ) )
- 블록 내에 있는 2000~3000개의 모든 트랜잭션은 최종 32바이트 길이의 머클트리 루트의 해시 값으로 요약돼 블록 헤더에 저장

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/497d4abf-2644-4d75-9988-a341cc7a75b2/Untitled.png)

- 각 트랜잭션의 고유 번호인 트랜잭션 아이디는 블록 해시와 마찬가지로 32바이트로 된 SHA-256 해시 값
- 트랜잭션 아이디는 그 자체가 해시 값
- 트랜잭션의 모든 데이터를 일렬로 배치한 후 SHA-256을 두 번 연속 적용해 만든 해시 값
- 머클트리 해시 과정

1. 자기 자식 노드에 있는 두 트랜잭션 아이디를 쌍으로 묶은 후 SHA-256 해시를 두번 적용
2. 두 자식 노드의 해시 값을 직렬로 연결한 후 SHA-256을 두 번 적용
3. 루트 노드에 최종 해시 값 하나만 남을 때 까지 반복

- 해시 값은 맨 아래 트랜잭션 아이디가 모두 종합돼 만들어진 해시 값
- 각 트랜잭션 아이디는 모든 트랜잭션 데이터를 대상으로 만든 해시 값

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f79be82e-8d96-4be4-95e0-c37faa9346c1/Untitled.png)

- 세 번째 트랜잭션(Tx3)의 조작을 시도하는 즉시 그 부모 노드의 해시값이 달라지고 연쇄적으로 머클트리 루트의 해시 값까지 달라짐
- 머클트리의 구조상 어떤 트랜잭션을 조작하더라도 머클트리 루트 해시 값은 반드시 달라지므로 모든 조작을 바로 탐지할 수 있게 됨

## 암호화 기법

- 문장을 암호화해뒀다가 필요할 경우 언제든 원래의 문장을 복원해내는 기술
- 해시 함수는 사소한 변경도 손쉽게 탐지할 수 있지만 해시 값으로 부터 원래 메세지를 복원하는 것은 불가능
- 암호화 기법과 해시함수는 확연히 구분됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/206163d9-e680-4599-8dc8-2ce0b141f5a0/Untitled.png)

- 암호화기법은 암호화를 통해 문장의 비밀을 보호하거나 복호화를 통해 원래 문장을 완벽하게 복원하는 기술

### 암호화 방식 두가지

- 대칭형 암호화 기법: 암호화와 복호화 모두 동일한 키를 사용하는 방식
- 비대칭형 암호화 기법: 암호화할 떄와 복호화할 때 서로 다른 키를 사용하는 방식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/255174c5-47d8-45f7-b75b-4943668e7967/Untitled.png)

- 원래 메세지를 M, 암호화 알고리즘을 E ( ), 복호화 알고리즘을 D ( )

      암호화 사용 키를 KE, 복호화 사용 키를 KD

- 대칭형 암호화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fdfc266-f067-4a40-a158-e11494fda013/Untitled.png)

- 비대칭형 암호화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dc9dc37c-c81c-48ec-92d1-fdc1800d8264/Untitled.png)

## 비대칭 암호화 기법

- 한 쌍의 키를 이용해 암호화와 복호화를 수행
- 암호화는 어느 키를 사용하든 가능

### 개인키 또는 비밀키

- 본인만이 비밀로 간직하는 키
- 개인키를 사용해 암호화하면 짝인되는 공개키를 통해서만 복호화 가능

### 공캐키

- 일반에게 공개하는 키
- 공개키를 사용해 암호화하면 짝이되는 개인키로만 복호화 가능

### 개인키와 공개키 생성과정

- 임의의 개인키를 랜덤으로 생성
- 그 개인키로부터 특정 알고리즘을 적용해 그 쌍이 되는 공개키를 도출해 사용
- 공개키를 통해서는 어떤 방법으로도 개인키를 유추하거나 생성할 수 없음
- 공개키를 가진 사람은 오직 짝이 되는 개인키로 암호화된 문장을 복호화하는 일만 수행

## 비대칭 암호화 기법은 암호화하는 키에 따라

크게 두가지 용도로 분류

## 1. 개인키로 암호화 - 전자 서명

### 전자 서명의 역할을 하기위해 만족해야하는 두가지 성질

1. 위조 불가 (unforgeable)
   - A가 메시지 M에 대해 전자 서명 Sig(A,M)을 생성했다면, 그 누구도 동알한 메세지와 전자 서명 쌍인 [M, Sig(A,M)]을 생성할 수 없어야 한다
2. 인증 (authentic)
   - B가 A로 알려진 사람으로부터 메시지와 서명의 쌍 [M, Sig(A,M)]을 수령했을 떄, 이것이 정말로 A가 서명한 것이 맞는지 확인할 수 있는 방법이 존재해야 한다. 또한 오직 A만이 이 서명을 만들 수 있어야 하며, 이 서명은 메시지 M에 완전히 귀속돼야 한다

- 비대칭 암호화 기법을 활용하면 메시지를 만든 사람과 그 메시지의 진위를 쉽게 검증가능

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/366c952d-f7be-4f3c-82dc-fdb1554440f1/Untitled.png)

- 전자 서명의 용도로 사용할 때는 개인키로 암호화한 후 공개키로 복호화하는 방법으로 사용
- 메시지가 공개키로 복호화된다는 사실은 메시지가 분석가의 개인키로 암호화됐다는 것을 증명
- 투자 전문가가 작성한 것이 확실하다는 것을 증명

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef31635d-737f-43a2-b406-8c9738e788fb/Untitled.png)

- 전자 서명을 이용할 때는 전체 메시지를 암호화하는 것이 아님
- 메시지의 해시 값만을 암호화하는 방식

1. 송신자가 메시지와 함께 이 메시지의 해시를 암호화한 전자 서명을 송신
2. 수신자는 전자 서명을 송신자의 공개키로 복원한 값과 메시지를 해시한 값을 대소해 진위를 파악

- 해시 함수를 H ( ), 개인키를 K PRIV, K PUB
- 문서에 전자 서명하는 것은 다음과 같이 나타냄

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e25f2df0-20e8-4c68-9dd5-ee621cff0604/Untitled.png)

- 문서에 전자 서명을 한다는 것은 → 문서의 해시를 만듦 H ( M )
  → 그 해시 값을 개인|키로 암호화 E ( H ( M ), K PRIV )
- 문서의 해시 값을 계산한 후 복호화된 전자 서명 값과 일치하는지 비교

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5fa5053-7e72-4d3b-b0dc-67d7fb62ad64/Untitled.png)

## 2. 공개키로 암호화 - 비밀 보장 및 신원 증명

- 공개키로 암호화하고 개인키로 복호화하는 방식
- 암호화된 문서는 개인키를 가진 사람 이외에는 누구도 복호화할 수 없으므로 완벽한 비밀보장
- 공개키로 암호화된 문서를 복호화할 수 있는 사람은 쌍이 되는 개인키를 가진 사람뿐이므로 그 자체로 이문서를 읽을 자격이 있음을 증명되는 셈

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ac4012d4-538f-4c69-acb9-d060048faf93/Untitled.png)

- UTXO에 잠금 장키를 설정한 방법이 비대칭 암호화 기법
- UTXO를 소유하게 될 사람의 공개키 정보를 이용해 잠금 장치를 설정
- 쌍이 되는 개인키를 가진 사람만 잠금 장치를 열 수 있도록 구현

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/decba3ec-001a-42cf-bb3e-f224208ecb63/Untitled.png)

### 블록체인의 전자 서명과 비대칭 암호화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6dcae4d8-2d83-44df-9637-d8f03dddda31/Untitled.png)

### ③은 전자서명

### ④는 이 UTXO를 사용하려고 시도하는 사람의 공개키

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/472cb3a9-8eca-42e0-a171-f4e02ce815ba/Untitled.png)

### ① B가 집행하려는 전체 거래 내역에 대해 자신의 개인키를 사용해 전자서명

- 거래내역에는 B의 전자서명<Sig>와 공개키<Pubkey>가 함께 기록(ScriptSig)
- 모든사람이 B의 전자서명을 B의 공개키를 이용해 위조된 적 없는지 즉시 검증 가능

### ② A가 B에게 지급한 UTXO의 실제 소유자가 맞는지 증명

- 비트코인 주소에는 수령자의(B) 공개키를 암호화 해시한 정보가 들어있음
- 수령자의(B)의 공개키를 비트코인 주소에 들어 있는 암호화 해시된 공개키(B의 Pubkey Hash)와 비교해 보면, 그 실제 소유자를 손쉽게 확인 할 수 있다
- B의 비트코인 주소에 B의 공개키 해시 값이 포함돼 있음
- 전자 서명을 검증할 때 사용한 B의 공개키의 해시 값을 구한 후 이 값과 일치하는지 대조

# 작업 증명과 지분 증명

- 리더를 견제할 수 있는 유일한 방법은 나머지 모든 구성원이 검증을 통해 블록에 대한 동의 여부를 결정하는 것
- 리더를 선출하는 규칙
  - 작업 증명
  - 지분 증명

## 작업증명

- 서비스의 거부 공격이나 스팸등으로 네트워크 자원이 오·남용되는 것을 방지하기 위해 고안된 기법
- 서비스를 원하는 자에게 결코 작지 않은 그러나 처리 가능한 수준의 과제를 요구하는 것이 핵심
  - 과제란 주로 컴퓨터 계산 자원을 소모해야하는 일을 의미
- 작업 증명의 기본 철학은 나쁜 짓을 하려면 많은 자원을 소모하도록 해 나쁜짓을 최대한 억제하자는 것
- 비트코인이 적용한 작업 증명은 해시 퍼즐의 정답을 찾는 것

### 비트코인의 작업 증명 - 해시 퍼즐

- 임의로 꺼낸 공에 적힌 숫자가 0보다 작거나 같을 확률은 1/10
- 4보다 작거나 같을 확률은 1/2
- 찾으려는 수가 작을수록 그 확률은 낮아진다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e69bce0c-997d-44c0-859d-4c877bd8354a/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/480098d8-c564-43a5-bf0a-f2c46c6034fd/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d28ffd87-2b20-43c4-987c-dd56cea66c58/Untitled.png)

- 해시 값은 완전히 예측 불가해 앞에 연속된 0이 나오는 것은 순전히 우연에 의한 것이므로 언제 나타날지 예측할 수 없다
- 해시 퍼즐이란 계산된 해시 값이 시스템에서 주어진 목푯값보다 작아지게 만드는 정수인 난스를 찾는 과정
- 50만 번 블록의 목푯값

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81b8f0e8-6536-4d62-a4bc-b840d95b8af7/Untitled.png)

- 32바이트로 이뤄진 정수의 앞부분에 연속된 0이 증가할수록 당연히 그 값은 점점 작아진다
- 모두 0으로만 채워진다면 값은 0
- 모두 1로만 채워진다면 최댓값은 2^256-1
- 연속된 0이 증가한다는 의미는 찾아야할 값이 점점 작아지는 것과 같다
- 찾아야 할 값이 작아질수록 그 확률은 낮아지고, 이를 찾기 위해 필요한 시행 횟수는 반대로 증가할 것이다

1. nonce = 0으로 설정
2. Target 변수에 비트코인 시스템에서 부여받은 목푯값을 대입
3. Hash(block(m), n)을 계산한다. block(m)은 m번 블록 헤더에 있는 모든 데이터를 일렬로 정렬해 표현한 정수다.
   Hash(block(m), n)는 block(m)데이터의
   난스 값을 n으로 대체한 후 SHA-256을 두 번 연속 적용해 구현한다
4. Hash(block(m), n) ≤ Target이면 6번 절차로 분기한다
5. 난스 1 증가시킨 후 3번 절차로 분기
6. 난스를 찾았으므로 프로그램을 종료

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/419b2f74-988d-4093-a8be-5f925e011aed/Untitled.png)

### 해시 퍼즐의 난이도

- 해시 퍼즐의 난이도를 조절하는 것은 목푯값을 조절하는 것과 같다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1579e245-72ad-4c89-a043-f395bcd10716/Untitled.png)

- 해시 함수를 사용해 계산한 특정 해시 값X가 T보다 작을 확률
  - $P(X<T)=T/2^N=2^-k$
- T보다 작은 값을 찾기 위해 필요한 평균 시행 횟수
  - $1/P(X<T)=1/2^-k=2^k$
- m번 블록의 목푯값 = Tm
- 제네시스 블록의 목푯값을 T0
- m번 블록의 난이도 = T0/Tm

### 비트코인의 난이도 조절

- 비트코인은 2,016개의 블록이 생성될 때마다 난이도를 재조정
- 예정보다 더 빨리 블록을 만들면 난이도를 상향 조정함
- 예정보다 늦게 블록이 만들어 졌다면 난이도를 하향 조절한다

### 연쇄 해시를 이용한 비가역성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a466fd0e-91fd-4ad3-b638-eb3f80a08b26/Untitled.png)

- 현재 블록의 해시(ID) 값을 계산하기 위해 이전 블록의 해시 값을 사용
- 현재 블록의 해시 값을 계산하기 위한 함수에 이전 블록의 해시 값이 매개변수로 사용되는 셈

### Hn = Hash( Bn, Hn-1 )

### Hn = Hash( Bn, Hn-1 ) = Hash( Bn, Hash ( Bn-1, Bn-2 ) )

### Hn = Hash( Bn, Hash( . . . ( Hash( B0, NULL) ) . . . . . . . ) )

1. Hm이 변경되면 ,∀k, k>=m에 대해 Hk 값도 변경된다
2. Hm은 Hm-1 값을 확정하기 전에 미리 계산할 수 없다

- 연쇄 해시와 작업 증명 그리고 탈중앙화 합의라는 세 가지 속성이 합쳐지면, 한 번 기록된 것을 변경하는 것이 지극히 힘든 저장 방식을 구현할 수 있게 되며, 이처럼 계산량이 너무 많아 엄두도 내지 못하게 하는 방식을 ‘엄두도 못낼 비용’이라 표현한다

## 지분 증명

- 시스템에 대한 기여도가 높은 사람을 리더로 선출하자는 것
- 현재 보유하고 있는 암호 화폐의 수량이 가장 많은 노드를 리더로 선출하는 것
- 이 때문에 리더 선출을 위해 해시 퍼즐을 해결하는 등 에너지를 소모하는 작업은 더 이상 필요 없다

### 체인-기반의 지분 증명

- 사전에 정해진 소수의 집단이 블록을 만들고 검증
- 정해진 소수의 집단 중 보유 암호 화폐 수량 등을 고려한 종합 점수가 시스템이 정한 최저 임계치를 넘는 노드들에게 블록 생성권이 주어진다
- 임계치를 넘은 노드가 여러 개가 되면 블록이 동시에 생성 될 수 있으며, 이 경우 합의는 가장 무거운 체인을 선택한다
- 잃을 게 없는 딜레마에 의한 이중 공격 등의 위험에 노출될 수 있다

### BFT-기반의 지분 증명

- 사전에 정해진 소수의 노드중 랜덤으로 선출된 리더가 블록을 생성하고, 나머지 노드는 투표 방식으로 검증해 블록의 최종 승인을 결정
- 무거운 체인과 같은 합의 규칙은 존재하지 않는다
- 대다수 노드에 의해 악의적인 노드로 지목되면, 그 노드가 보유한 모든 암호화폐를 폐기해 버리는 극단적 방법인 슬래시 규칙을 적용한다

### BFT-기반 지분 증명이 작업 증명이나 체인-기반 지분증명보다 합리적인 방식이다를 반문

- BFT-기반 지분 증명은 다수결에 참여한 소수의 노드를 전적으로 신뢰해야만 작동하는 방식으로, 신뢰가 필요 없는 네트워크에서 작동하는 작업 증명 방식과는 완전히 다르다

### 잃을 것이 없는 딜레마

- 블록을 생성하는 데 에너지가 소모되지 않아, 무분별한 충돌을 통해 소수의 해시 파워만으로도 시스템을 남용하는 현상
- 잃을 것이 없는 딜레마가 시사하는 것은 작업 증명이 사라지면 소수의 노드만으로도 다양한 형태로 시스템을 교란할 수 있다는 것이다

<aside>
💡 인간이 늘 경제적인 합리성을 추구한다면 지분 증명은 그 안정성을 뒷받침해줄 이론적
근거가 없다

</aside>

# 하드포크와 소프트포크

- 수만 명 또한 수십만 명이 자발적으로 모인 블록체인 생태계에서 모든 참여자가 항상 자신의 소프트웨어를 최신 버전으로 갱신한다는 것은 현실적으로 불가능
- 모든 노드가 동시에 업그레이드하는 것은 불가능하므로 상당 기간 동안 새로운 소프트웨어로 업그레이드한 노드와 그렇지 않은 노드가 시스템상에 서로 혼재하게 됨으로써 새로생긴 규칙과 이전의 규칙 사이에 충돌이 발생할 수 있다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55aedbd1-f24d-4498-9a42-63e17a51fccc/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/551d541c-a1e0-4fc0-973b-f760bb7d84e4/Untitled.png)

### 과거에는 무효하던 규칙을 유효화 - 하드포크

- 과거에는 무효하던 규칙을 유효로 변경하는 변화가 일어나 모든 노드가 새로운 시스템으로 변경해야만 블록체인 데이터가 통일되는 경우를 하드포크라고 한다
- B그룹은 A그룹에 비해 훨씬 더 다양한 블록을 생상할 수 있게 됨
- A그룹이 자신들만의 규칙으로 생성하는 블록체인 데이터와 B그룹이 생성하는 블록체인 데이터가 각각 따로 자라게 되됨
- 두 블록체인 데이터는 하나로 합쳐질 수 없다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b185ee8d-ca77-48d2-b446-91283427bb5a/Untitled.png)

### 과거에는 유효하던 규칙을 무효화 - 소프트포크

- 과거에 사용하던 규칙 중 뒤늦게 보안에 심각한 위협을 끼친다고 확인된 규칙이 발견되면 그 규칙을 무효화하는 경우가 있을 수 있음
- 과거에는 유효하던 규칙이 무효화되는 변경이 일어났을 때 새로운 규칙을 따르는 노드가 이전 규칙을 따르는 노드에 비해 다수가 되는 순간, 모두 새 규칙을 따르게 되는 것을 소프트포크라함
- B그룹이 생산한 블록체인 데이터가 조금이라도 더 무거워지면 소프트웨어의 업그레이드와는 상관없이 무조건 새로운 규칙에 맞게 통일됨
- A그룹 입장에서도 B그룹에서 생성한 모든 블록이 유효한 것으로 판단되므로 B의 블록체인 데이터가 조금이라도 무거워지는 순간, 즉시 탈중앙화 합의에 의해 B블록체인 데이터로 통일할 것이기 때문
- 소프트포크는 새로운 규칙에 찬성하는 그룹이 더 많아져야 설공할 수 있다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eafae0cf-8a19-4188-89e7-3e87bac6d907/Untitled.png)

### 사용자 활성화 소프트포크 (UASF, User Activated Soft Fork)

- 채굴자들에 의존하지 않고 전체 완전 노드의 의견에만 의존해 소프트포크를 진행하려는 방식

### 채굴업자 활성화 소프트포크 (MASF, Miners Activated Soft Fork)

- 시스템 절대 해시 파워를 갖고 있는 채굴자들의 의견에 의존해 소프트포크를 진행하려는 방식
- MASF로 진행한 소프트 포크는 실패할 확률이 적고 신속하게 반영할 수 있지만, UASF로 진행한 소프트포크는 향후 채굴업자의 협조 여부에 따라 실패할 가능성도 배제할 수 없으며 반응 속도도 느린 편이다
- MASF는 채굴업자들이 악용할 경우, 시스템에 악영향을 끼칠수 있다

## 세그윗과 세그윗2X

- 하드포크를 하지 않고도 블록의 크기가 늘어난 것과 같은 효과를 얻을 수 있는 아이디어가 제안
- 소프트포크를 이용해 마치 블록의 용량을 늘린 하드포크와 같은 효과를 줄 수 있는 방방이 제안됐는데 이름 세그윗이라 부름

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6acb3e66-36cd-4f31-a981-8c280a2d832d/Untitled.png)

- 세그윗은 입력에 있는 이 부분을 완전히 분리한 후 기존의 1메가바이트 블록 영역 밖의 새로운 데이터 구조 영역으로 옮긴다는 아이디어
- 서명 분리를 통해 생긴 빈 공간에는 더 많은 트랜잭션을 담을 수 있어 블록이 확장된 효과를 누릴 수 있고, 분리한 서명은 기존의 1메가바이트 블록 영역 밖으로 이동해 저장함으로써 블록이
  1메가바이트를 넘을 수 없다는 기존의 규칙도 그대로 지킬 수 있는 일석이조의 효과를 얻음
- 세그윗은 기존의 바이트 단위대신 가중치유닛(WU)이라는 새로운 무게 단위를 도입
- 1B=1WU
- 전자 서명을 분리해 새로 추가한 전자 서명의 영역은 1B=1WU
- 전체 영역은 400만 WU로 제한
- 하드포크가 필요했던 사안을 데이터 위치 재배열이라는 아이디어를 통해 기존의 규칙을 지키면서도 용량이 늘어난 듯한 효과를 얻는 소프트포크로 진행

### 세그윗 2X

- 세그윗과는 달리 하드포크를 무릅쓰고라도 하루 빨리 블록의 용량을 확대하자는 주장

## 51%공격

- 리더는 편중됨이 없이 최대한 랜덤하고 다양하게 선출돼야 생태계의 안정성을 극대화할 수 있다
- 어느 한 집다에서 지속적으로 리더가 선출되는 상황이 발생하면, 시스템의 무결성과 안정성은 심각한 타격을 입는다
- 해시 퍼즐을 풀기 위해 동원할 수 있는 계산 능력을 통상 해시 파워라 부름
  - 해시 퍼즐을 해결할 수 있는 힘
- 블록 생산력을 악용해 자신들이 원하는 대로 트랜잭션을 임의로 구성함으로써 시스템을 공격할 수 있는데, 이러한 극단적인 상황을 상징적으로 ‘51% 공격’이라고 한다

### 51% 공격이 발생할 가능은 충분하지만 가능성은 낮은 이유

- 51% 공격을 위해서는 하드웨어 등의 자원에 막대한 투자를 해야 하는데 그 투자 규모에 비해 시스템을 장악한 후에 얻을 수 있는 실익이 정작 그리 크지 않다
- 공격을 감행할 정도의 해시파워를 가진 세력은 대부분 대형 채굴업자들로서, 기존에 채굴한 암호 화폐를 가장 많이 보유하고 있는 큰손들이기 때문

# 비잔틴 장군 문제와 블록체인

- 분산 시스템은 여러 서버에서 일을 나눠함으로써, 작업의 효율으리 꾀하고 서로 항상 같은 상태를 유지해야 한다
- 분산된 서버들의 상태를 일치시키는 방법은 고장-중단 모델과 비잔틴 장군 모델이 있다
- 각각의 모델에서의 연구 과제는 네트워크를 구성하는 N개의 노드 중 m개의 노드가 고장 났을 때 여전히 서로의 상태를 일치시킬 수 있을 것인지를 알아내는 것과 상태 일치가 가능한 최대 m값이 무엇인지, 그때의 일치시키는 알고리즘은 어떤 것이 최적인지를 찾아내는것

## 고장-중단 모델

- 노드가 가질 수 있는 상태는 두가지
  - 정상적인 작동
  - 고장으로 인해 멈추는것
- 합의 방법
  - 단순히 고장 난 노드를 네트워크에서 제거해나가면 된다
  - 단 하나의 노드라도 정상적으로 작동하면 언제든 합의에 이르게 된다

## 비잔틴 장군 모델

- 네트워크에서 바생하는 오류에 대해 아무런 가정도 하지 않고, 모든 가능성을 고려한 극단적인 상황을 설정한 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/541ba209-bd65-426f-9b4d-26b7f0d324c4/Untitled.png)

- 누가 어떤 식으로 메시지를 왜곡하느냐에 따라 각 장군들은 다른 정보를 전달받게 될 것이므로, 서로 하나의 통일된 메시지로 합의할 수 있는 방법을 찾아야한다
- 모든 전달은 서명한 편지를 통해 이루어지며, 이 서명은 위조나 변조할 수 없다는 조건을 추가하면 문제는 쉬워진다
- 견딜 수 있는 최대 고장 노드 개수 m은 N/3라는 것이 증명돼 있으며, 이는 전체 노드 중 최소한 2/3 이상은 정상적으로 작동하고 있어야 합의를 이룰 수 있다는 의미
- 비잔틴 장군 문제 중 데이터가 어느 노드에서 출발할 것인지, 중간에 조작된 것인지 등에 대한 어떠한 정보도 얻을 수 없는 경우는 가장 난이도가 높은 네트워크 환경이다
- 데이터가 어디서 왔는지 알 수 있다면, 거짓된 정보라는 것을 확인하는 순간 그 노드를 네트워크에서 배제시키면 되지만, 거짓 정보를 계속 받더라도 누가 보낸 것인지 특정할 수 없다면, 네트워크에는 지속적으로 거짓 정보가 돌아다니게 된다
- 비트코인 블록체인에서는 모든 트랜잭션을 송신자의 개인키를 이용해 전자 서명하는 방법으로 방지하고 있기 때문에 비잔틴 장군 모델 중 전령들이 서명한 편지를 전달하는 모델에 더 가깝다

# 블록체인과 보안

## 블록체인을 둘러싼 보안 환경

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80a2c80f-b6cf-4626-9af6-f55793104b99/Untitled.png)

1. 블록체인
   1. 탈중앙화 원장을 구성하는 기본 개념의 집합, 특정 응용 분야에 국한되지 않음
2. 비트코인 시스템
   1. 암호화폐라는 응용 분야에 블록체인을 이용한 것
   2. 블록체인 기본 개념과는 다른 별개의
      보안 문제가 존개
3. 비트코인 지갑
   1. 블록체인의 기본 개념이나 암호화폐라는 응용 분야와 직접적으로 상관 없는 응용 프로그램
   2. 사용자의 거래상 편의를 위해 만들어진 소프트웨어
   3. 일반 응용 프로그램이 가질 수 있는 기본적인 안전 문제를 모두 갖고 있다
4. 비트코인 외부 환경 요소
   1. 비트코인 및 블록체인과 상관이 없고, 이 부분이 없더라도 비트코인의 사용에 있어 아무런 제약이 없다
   2. 거래의 편의를 위해 추가로 생긴 기능들로 중개소 등의 서비스나 응용 프로그램이다
   3. 여기서 생기는 보안 문제는 비트코인 시스템이나 블록체인과는 완전히 구분 됨
   - 중개소가 만든 지갑을 사용하면 3과4의 경계가 모호해진다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2cabe306-d44a-48f7-9e9f-5a77ef1630e0/Untitled.png)

| 대상구분 | 설명 | 대표적인 예 | 비고 |
| -------- | ---- | ----------- | ---- |

| 블록체인 자체의
안정성 | 탈중앙화 원장 기술 자체의 안전성
(내재적 안전성) | 블록체인 | 비트코인
내부 환경 |
| 블록체인의 응용인
비트코인 시스템의
안정성 | 최초의 블록체인 기반 암호 화폐라는 블록 체인의 특정 응용 분야로서의 안전성
(응용적 안정성) | 비트코인 시스템 | 비트코인
내부 환경 |
| 비트코인을 사용하기
위한 지갑 프로그램 | 기반 기술과 상관없이 사용자 환경 프로그램이 갖고 있는 안전성 및 사용자의 보안 의식
(개별적 안정성) | 비트코인 지갑 | 비트코인
내부 환경 |
| 비트코인 외부의
편의 프로그램들 | 비트코인 시스템과 상관없이 사용의 펴느이성을 위해 생겨난 개별 서비스나 프로그램
(외재적 안정성) | 중개소 | 비트코인
외부 환경 |

## 블록체인 - 내재적 안정성

- 블록체인의 안정성은 개념의 안정성
- 블록체인을 이용해 구현된 모든 응용 프로그램이 공통으로 갖게 되는 내재적 안전성 부분
- 데이터의 분산과 중앙 통제의 부재 → 시스템의 중단이나 위·변조 공격에는 안전함
  - 공격으로 삼을 대상이 뚜렷하지 않음
- 시스템의 중단이나 위·변조 공격을 제외한 나머지 해킹 공격으로부터는 거의 무방비 상태
  - 브로드 캐스팅을 통해 노출되기 때문
- 블록체인은 보안도구가 아님
  - ‘분산’과 ‘연쇄 해시’라는 보편적인 보안 관련 성질을 사용하고 있는것 뿐임

## 비트코인 시스템 - 응용적 안정성

### 코어 소프트웨어 시스템의 안전성

- 비트코인은 블록체인의 기본 개념을 그대로 구현한 것
- 이 문제는 블록체인의 내재적 안정성과는 상관없으며, 특정 응용 프로그램에만 국한
- 프로그래머의 모임이 만들고 유지보수하고 있는 프로그램 코드의 무결성과 안정성은 그 누구도 담보할 수 없다
  - 비트코인 개발자의 뒤에는 대규모 자금을 지원하는 재단이있고 그 재단 뒤에는 채굴업자등이 존재
- 소프트웨어에 결함이 있다면 언제든지 모든 기능이 마비될 수 있다

### 기본 설계의 안전성

- 해킹 등의 위협으로부터는 안전하지만 비트코인만의 응용적 특징으로 인해 여러 위협 요소 존재
  - 해시 퍼즐과 난이도 조절의 결함
  - 인센티브 공학적 결함

### 해시 퍼즐과 난이도 조절의 결함

- 채굴의 독점은 심하게 가속화
- 비트코인을 설치한 사람은 모두 단 10개 업체에 전체 트랜잭션을 의존 중
- 채굴 편중의 주범은 해시 퍼즐과 난이도 조절 설계의 결함
- 비트코인의 난이도 조절은 무어의 법칙에 따른 하드웨어 발달을 대비한 것
- 해시 퍼즐이 전용 기계를 동원한 자원의 독점을 효과적으로 막지 못한 설계상의 결함

### 인센티브 공학적 결함

- 소프트웨어는 통상 편리한 사용 도구기능에 집중
- 블록체인은 도구가 아니라 운영의 안전성을 위한 인센티브 공학이 훨씬 중요
- 블록체인은 누군가 끊임없이 노동력을 제공해야만 무결성을 유지할 수 있다
- 결함
  - 모든 인센티브가 오로지 채굴업자에게만 주어진다
    - 수만 개의 노드가 자신의 에너지를 소비하며, 무결성 검증에 참여하지만, 인센티브는 단 한푼도 없다 → 검증에 참여할 동인이 없음
  - 인센티브가 암호화폐로 설계돼 있다
    - 암호화폐의 내재 가치는 0원

## 비트코인 지갑 - 개별적 안정성

- 비트코인 시스템과는 상관없이 여러업체들이 경쟁하듯 PC버전과 스마트폰 버전을 배포 중
- 위협 두가지
  - 지갑 소프트웨어 자체의 문제
    - 지갑의 안정성이 담보돼 있지 않음
      - 경우에 따라 여러 취약성을 가진 지갑을 배포하는 회사도 있을 수 있으며, 위장한 해커들이 지갑으로 꾸며 배포할 수도 있다
    - 지갑 프로그램 자체가 가진 보안 취약성에 고스란히 노출 돼 있음
    - 블록체인이 가진 내재적인 문제나 비트코인 시스템의 응용 문제가 아닌 특정 지갑 소프트웨어로 인해 발생하는 문제
  - 지갑 사용자의 문제
    - 사용자의 부주의와 관련 됨
    - 비밀번호 관리를 소홀히 해 개인키가 타인에게 노출되는 상황이 초래되면 돌이킬 수 없는 피해가 초래된다
  - 두가지 위험은 모두 개별적인 위험으로서 그 안전성이 깨졌을 떄 피해는 어느한 개인으로만 국한되고, 집단적 피해를 초래하지 않는다

## 중개소 등 외부환경 - 외재적 안전성

- 암호화폐를 사용을 위한 필수 요소가 아니라 단지 편의를 위한 서비스만 제공하는 모든 환경을 외부 환경으로 분루할 수 있음
- 서비스 제공 업체별로 서로 다른 안전 문재가 존재
- 중개소의 피해는 집단적일 수 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2553441-ef39-4cfd-a535-cdf76b90592a/Untitled.png)

- 대부분 중개소는 사용자의 편의를 위해 임의로 만든 지갑을 이용해 거랠ㄹ 대행 하기 때문에
  A와B는 단 한번도 비트코인을 사용한 적이 없다
- Z는 비트코인 지갑을 별도로 설치해 필요한 경우 중개소에 맡겨져 있는 비트코인을
  자신의 비트코인 주소로 옮길 수 있다
- 중개소가 사용하는 시스템이나 기술은 중개 거래 시스템
- 블록체인과는 무관하고 암호 화폐와도 상관없다
- 중개소를 해킹한 후 다른 사람이 보유하고 있는 암호화폐를 자신의 비트코인 주소로 옮겨오면 추적이 불가능하다
- 이 부분의 안전성은 블록체인이나 비트코인 시스템의 안전성과는 관련이 없다 따라서 외재적 안전성이 되는 것
